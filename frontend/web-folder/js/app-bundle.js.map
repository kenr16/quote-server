{"version":3,"file":"app-bundle.js","sources":["../../../../node_modules/tslib/tslib.es6.mjs","../../node_modules/dom-native/dist/utils.js","../../node_modules/dom-native/dist/event.js","../../node_modules/dom-native/dist/hub.js","../../node_modules/dom-native/dist/ts-decorator-on-event.js","../../node_modules/dom-native/dist/ts-decorator-on-hub.js","../../node_modules/dom-native/dist/c-base.js","../../node_modules/dom-native/dist/dom-builders.js","../../node_modules/dom-native/dist/escapes.js","../../node_modules/dom-native/dist/ts-decorator-custom-element.js","../../src/ui/todo-mvc.ts"],"sourcesContent":["/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","// --------- Object Utils --------- //\n// return true if the value is null, undefined, empty array, empty string, or empty object\nexport function isEmpty(v) {\n    const tof = typeof v;\n    if (v == null) {\n        return true;\n    }\n    if (v instanceof Array || tof === 'string') {\n        return (v.length === 0) ? true : false;\n    }\n    if (tof === 'object') {\n        // apparently 10x faster than Object.keys\n        for (const x in v) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\n// TODO: need to document\nexport function val(rootObj, pathToValue, value) {\n    const setMode = (typeof value !== \"undefined\");\n    if (!rootObj) {\n        return rootObj;\n    }\n    // for now, return the rootObj if the pathToValue is empty or null or undefined\n    if (!pathToValue) {\n        return rootObj;\n    }\n    // if the pathToValue is already an array, do not parse it (this allow to support '.' in prop names)\n    const names = (pathToValue instanceof Array) ? pathToValue : pathToValue.split(\".\");\n    let name, currentNode = rootObj, currentIsMap, nextNode;\n    let i = 0, l = names.length, lIdx = l - 1;\n    for (i; i < l; i++) {\n        name = names[i];\n        currentIsMap = (currentNode instanceof Map);\n        nextNode = currentIsMap ? currentNode.get(name) : currentNode[name];\n        if (setMode) {\n            // if last index, set the value\n            if (i === lIdx) {\n                if (currentIsMap) {\n                    currentNode.set(name, value);\n                }\n                else {\n                    currentNode[name] = value;\n                }\n                currentNode = value;\n            }\n            else {\n                if (typeof nextNode === \"undefined\") {\n                    nextNode = {};\n                }\n                currentNode[name] = nextNode;\n                currentNode = nextNode;\n            }\n        }\n        else {\n            currentNode = nextNode;\n            if (typeof currentNode === \"undefined\") {\n                currentNode = undefined;\n                break;\n            }\n        }\n    }\n    if (setMode) {\n        return rootObj;\n    }\n    else {\n        return currentNode;\n    }\n}\n// Convert an indexed object to a pure array in the most efficient way (to-date)\n// See: https://jsperf.com/convert-nodelist-to-array, https://jsperf.com/array-from-to-nodelist\nexport function listAsArray(list) {\n    const arr = new Array(list.length);\n    for (let i = list.length - 1; i >= 0; i--) {\n        arr[i] = list[i];\n    }\n    return arr;\n}\n// --------- /Object Utils --------- //\n// --------- ensureType --------- //\nexport function ensureObject(obj, propName) {\n    return _ensure(obj, propName);\n}\n// Make sure that this obj[propName] is a js Map and returns it. \n// Otherwise, create a new one, set it, and return it.\nexport function ensureMap(obj, propName) {\n    return _ensure(obj, propName, Map);\n}\n// Make sure that this obj[propName] is a js Set and returns it. \n// Otherwise, create a new one, set it, and return it.\nexport function ensureSet(obj, propName) {\n    return _ensure(obj, propName, Set);\n}\n// same as ensureMap but for array\nexport function ensureArray(obj, propName) {\n    return _ensure(obj, propName, Array);\n}\nfunction _ensure(obj, propName, type) {\n    const isMap = (obj instanceof Map);\n    let v = (isMap) ? obj.get(propName) : obj[propName];\n    if (v == null) {\n        v = (type == null) ? {} : (type === Array) ? [] : (new type);\n        if (isMap) {\n            obj.set(propName, v);\n        }\n        else {\n            obj[propName] = v;\n        }\n    }\n    return v;\n}\n// Return an array from a value object. If value is null/undefined, return empty array. \n// If value is null or undefined, return empty array\n// If the value is an array it is returned as is\n// If the value is a object with forEach/length will return a new array for these values\n// Otherwise return single value array\nexport function asArray(value) {\n    if (value != null) {\n        if (value instanceof Array) {\n            return value;\n        }\n        // If it is a nodeList, copy the elements into a real array\n        else if (value.constructor && value.constructor.name === \"NodeList\") {\n            return Array.prototype.slice.call(value);\n        }\n        // if it is a function arguments\n        else if (value.toString() === \"[object Arguments]\") {\n            return Array.prototype.slice.call(value);\n        }\n        // otherwise we add value\n        else {\n            return [value];\n        }\n    }\n    // otherwise, return an empty array\n    return [];\n}\nconst emptyArray = Object.freeze([]);\n/**\n * Returns a readonly Node array from EventTarget, NodeList, Node[], or empty readonly array for null and undefined.\n */\nexport function asNodeArray(value) {\n    if (value != null) {\n        if (value instanceof Array) {\n            return value;\n        }\n        // If it is a nodeList, copy the elements into a real array\n        else if (value.constructor && value.constructor.name === \"NodeList\") {\n            return Array.prototype.slice.call(value);\n        }\n        // FIXME: Needs to handle the document fragment case. \n        // otherwise we add value\n        else {\n            return [value]; // Note: here we assume it the evenTarget is a node\n        }\n    }\n    // otherwise, return an empty array (readonly, so that we can )\n    return emptyArray;\n}\n// --------- /asType --------- //\n// --------- String Utils --------- //\nexport function splitAndTrim(str, sep) {\n    if (str == null) {\n        return [];\n    }\n    if (str.indexOf(sep) === -1) {\n        return [str.trim()];\n    }\n    return str.split(sep).map(trim);\n}\nfunction trim(str) {\n    return str.trim();\n}\n// --------- /String Utils --------- //\nconst _printOnceDone = {};\nexport function printOnce(msg) {\n    if (!_printOnceDone[msg]) {\n        console.log(msg);\n        _printOnceDone[msg] = true;\n    }\n}\n//# sourceMappingURL=utils.js.map","import { asNodeArray, ensureMap, ensureSet, splitAndTrim } from './utils.js';\nexport function addOnEvents(target, source) {\n    return Object.assign(target || {}, source);\n}\nexport function on(els, types, arg1, arg2, arg3) {\n    let opts;\n    let listener;\n    let selector;\n    // arg1 is a function, then no selector, arg1 is the listener, and arg2 is the potential eventOptions\n    if (arg1 instanceof Function) {\n        listener = arg1;\n        opts = arg2;\n    }\n    else {\n        selector = arg1;\n        listener = arg2;\n        opts = arg3;\n    }\n    // AddEventListenerOptions\t\n    let eventOptions;\n    if (opts && (opts.passive != null || opts.capture != null)) {\n        eventOptions = {};\n        if (opts.passive != null) {\n            eventOptions.passive = opts.passive;\n        }\n        if (opts.capture != null) {\n            eventOptions.capture = opts.capture;\n        }\n    }\n    if (els == null) {\n        return;\n    }\n    const silenceDisconnectedCtx = opts?.silenceDisconnectedCtx;\n    const ctx = opts?.ctx;\n    const ctxEl = (ctx instanceof HTMLElement) ? ctx : undefined;\n    const typeArray = splitAndTrim(types, \",\");\n    typeArray.forEach(function (type) {\n        const typeSelectorKey = buildTypeSelectorKey(type, selector);\n        asNodeArray(els).forEach(function (el) {\n            // This will the listener use for the even listener, which might differ\n            // from the listener function passed in case of a selector\n            let _listener = listener;\n            // if we have a selector, create the wrapper listener to do the matches on the selector\n            if (selector) {\n                _listener = function (evt) {\n                    let tgt = null;\n                    const target = evt.target;\n                    const currentTarget = evt.currentTarget;\n                    const ctx = (opts) ? opts.ctx : null;\n                    // if the \n                    if (silenceDisconnectedCtx === true && ctxEl != null) {\n                        if (!ctxEl.isConnected) {\n                            return;\n                        }\n                    }\n                    // if the target match the selector, then, easy, we call the listener\n                    if (target && target.matches(selector)) {\n                        // Note: While mouseEvent are readonly for its properties, it does allow to add custom properties\n                        // TODO: type narrowing needed.\n                        evt.selectTarget = target;\n                        listener.call(ctx, evt);\n                    }\n                    // now, if it does not, perhaps something in between the target and currentTarget\n                    // might match\n                    else {\n                        // TODO: type narrowing needed.\n                        tgt = evt.target.parentNode;\n                        // TODO: might need to check that tgt is not undefined as well. \n                        while (tgt !== null && tgt !== currentTarget && tgt !== document) {\n                            if (tgt.matches(selector)) { // selector is present here (see if above)\n                                // Note: While mouseEvent are readonly for its properties, it does allow to add custom properties\n                                evt.selectTarget = tgt;\n                                listener.call(ctx, evt);\n                                tgt = null;\n                                break;\n                            }\n                            tgt = tgt.parentNode;\n                        }\n                    }\n                };\n            }\n            // if we do not have a selector, but still havea  opts.ctx, then, need to wrap\n            else if (opts && opts.ctx) {\n                _listener = function (evt) {\n                    if (silenceDisconnectedCtx === true && ctxEl != null) {\n                        if (!ctxEl.isConnected) {\n                            return;\n                        }\n                    }\n                    listener.call(opts.ctx, evt);\n                };\n            }\n            const listenerRef = {\n                type: type,\n                listener: listener,\n                _listener: _listener, // an eventual wrap of the listener, or just point listener.\n            };\n            if (selector) {\n                listenerRef.selector = selector;\n            }\n            // If we have a namespace, they add it to the Ref, and to the listenerRefsByNs\n            // TODO: need to add listenerRef in a nsDic if if there a opts.ns\n            if (opts && opts.ns) {\n                listenerRef.ns = opts.ns;\n                let listenerRefSetByNs = ensureMap(el, \"listenerRefsByNs\");\n                let listenerRefSet = ensureSet(listenerRefSetByNs, opts.ns);\n                listenerRefSet.add(listenerRef);\n            }\n            // add the listenerRef as listener:listenerRef entry for this typeSelectorKey in the listenerDic\n            let listenerDic = ensureMap(el, \"listenerDic\");\n            let listenerRefByListener = ensureMap(listenerDic, typeSelectorKey);\n            listenerRefByListener.set(listener, listenerRef);\n            // do the binding\n            // TODO: fix typing here.\n            el.addEventListener(type, _listener, eventOptions);\n        }); // /utils.asArray(els).forEach(function(el){\n    }); // /types.forEach(function(type){\n}\nexport function off(els, type_or_opts, selector_or_listener, maybe_listener) {\n    if (els == null) {\n        return;\n    }\n    // for now, opts is only the first position\n    const opts = (type_or_opts && type_or_opts.ns) ? type_or_opts : null;\n    const type = (opts === null) ? type_or_opts : null;\n    let selector = null;\n    let listener;\n    const tof = typeof selector_or_listener;\n    if (tof === 'function') {\n        selector = null;\n        listener = selector_or_listener;\n    }\n    else if (tof === 'string') {\n        selector = selector_or_listener;\n        listener = maybe_listener;\n    }\n    // --------- off(els, {ns}) --------- //\n    // if we have a .off(els,{ns:..}) then we do check only the ns\n    if (opts && opts.ns) {\n        const ns = opts.ns;\n        asNodeArray(els).forEach(function (el) {\n            const listenerDic = el.listenerDic;\n            const listenerRefsByNs = el.listenerRefsByNs;\n            let listenerRefSet;\n            if (listenerRefsByNs && listenerDic) {\n                listenerRefSet = listenerRefsByNs.get(ns);\n                if (listenerRefSet) {\n                    // if we get the set, we remove them all\n                    listenerRefSet.forEach(function (listenerRef) {\n                        // we remove the event listener\n                        el.removeEventListener(listenerRef.type, listenerRef._listener);\n                        // need to remove it from the listenerDic\n                        const typeSelectorKey = buildTypeSelectorKey(listenerRef.type, listenerRef.selector);\n                        const listenerRefMapByListener = listenerDic.get(typeSelectorKey);\n                        if (listenerRefMapByListener && listenerRefMapByListener.has(listenerRef.listener)) {\n                            listenerRefMapByListener.delete(listenerRef.listener);\n                        }\n                        else {\n                            // eventua already removed\n                            //console.log(\"INTERNAL INFO - should have a listener in el.listenerDic for \" + typeSelectorKey);\n                        }\n                    });\n                    // we remove this namespace now that all event handlers has been removed\n                    listenerRefsByNs.delete(ns);\n                }\n            }\n        });\n        return;\n    }\n    // --------- /off(els, {ns}) --------- //\n    const typeSelectorKey = buildTypeSelectorKey(type, selector);\n    asNodeArray(els).forEach(function (el) {\n        // First, get the listenerRefByListener for this type/selectory\n        const listenerRefMapByListener = (el.listenerDic) ? el.listenerDic.get(typeSelectorKey) : null; //val(el, [\"listenerDic\", typeSelectorKey]);\n        // for now, if we do not have a listenerRef for this type/[selector], we throw an error\n        if (!listenerRefMapByListener) {\n            console.log(\"WARNING - Cannot do .off() since this type-selector '\" + typeSelectorKey +\n                \"' event was not bound with .on(). We will add support for this later.\");\n            return;\n        }\n        // if we do not have a listener function, this mean we need to remove all events for this type/selector\n        if (typeof listener === \"undefined\" && type) {\n            listenerRefMapByListener.forEach(function (listenerRef) {\n                // Note: Here, type === listenerRef.type\n                // remove the event\n                // TODO: check typing assumption\n                el.removeEventListener(type, listenerRef._listener);\n            });\n            el.listenerDic.delete(typeSelectorKey);\n        }\n        // if we have a listener, then, just remove this one.\n        else {\n            // check that we have the map. \n            const listenerRef = (listener) ? listenerRefMapByListener.get(listener) : null;\n            if (!listenerRef) {\n                console.log(\"WARNING - Cannot do .off() since no listenerRef for \" + typeSelectorKey +\n                    \" and function \\n\" + listener + \"\\n were found. Probably was not registered via on()\");\n                return;\n            }\n            // remove the event\n            // TODO: check typing assumption\n            el.removeEventListener(type, listenerRef._listener);\n            // remove it from the map\n            // TODO: check typing ! assumption\n            listenerRefMapByListener.delete(listener);\n        }\n    });\n}\n//#endregion ---------- /Public off API ---------- \n//#region    ---------- Public trigger API ---------- \nconst customDefaultProps = {\n    bubbles: true,\n    cancelable: true\n};\nexport function trigger(els, type, evtInit) {\n    if (els == null) {\n        return;\n    } // for now make it null/undefined proof\n    asNodeArray(els).forEach(function (el) {\n        const evt = new CustomEvent(type, Object.assign({}, customDefaultProps, { selectTarget: el }, evtInit));\n        el.dispatchEvent(evt);\n    });\n}\n//#endregion ---------- /Public trigger API ---------- \n//#region    ---------- Public bindDOMEvents API ---------- \n/**\n * Bind a list of bindings\n *\n * @param typeAndSelector e.g., `click` or `click; button.add`\n */\nexport function bindOnEvents(el, eventDics, opts) {\n    eventDics = (eventDics instanceof Array) ? eventDics : [eventDics]; // make we have an array of eventDic\n    for (const eventDic of eventDics) {\n        for (const selector in eventDic) {\n            bindOnEvent(el, selector, eventDic[selector], opts);\n        }\n    }\n}\n/**\n * Bind one event to a el by appropriately parsing the `typeAndSelector` might contains a selector;\n *\n * @param typeAndSelector e.g., `click` or `click; button.add`\n */\nexport function bindOnEvent(el, typeAndSelector, fn, opts) {\n    let selectorSplitted = typeAndSelector.trim().split(\";\"); // e.g., [\"click\", \" button.add\"]\n    let type = selectorSplitted[0].trim(); // e.g., \"click\"\n    let selector = null; // e.g., \"button.add\"\n    if (selectorSplitted.length > 1) {\n        selector = selectorSplitted[1].trim();\n    }\n    on(el, type, selector, fn, opts);\n}\n//#endregion ---------- /Public bindDOMEvents API ---------- \nfunction buildTypeSelectorKey(type, selector) {\n    return (selector) ? (type + \"--\" + selector) : type;\n}\n//# sourceMappingURL=event.js.map","import { ensureArray, splitAndTrim } from './utils.js';\n;\n//#endregion ---------- /Public Types ---------- \n//#region    ---------- Public bindHubEvents ---------- \nexport function addHubEvents(target, source) {\n    const t = (target == null) ? [] : (target instanceof Array) ? target : [target];\n    (source instanceof Array) ? t.push(...source) : t.push(source);\n    return t;\n}\nexport function bindHubEvents(bindings, opts) {\n    const bindingList = (bindings instanceof Array) ? bindings : [bindings];\n    for (const bindings of bindingList) {\n        const infoList = listHubInfos(bindings);\n        infoList.forEach(function (info) {\n            info.hub.sub(info.topics, info.labels, info.fun, opts);\n        });\n    }\n}\n/**\n * Unbinding a list of bindings. For now, MUST have nsObject.\n * @param bindings\n * @param nsObject\n */\nexport function unbindHubEvents(bindings, nsObject) {\n    const bindingList = (bindings instanceof Array) ? bindings : [bindings];\n    bindingList.forEach(function (hubEvents) {\n        const infoList = listHubInfos(hubEvents);\n        infoList.forEach(function (info) {\n            info.hub.unsub(nsObject);\n        });\n    });\n}\n/**\n * @param {*} hubEvents could be {\"hubName; topics[; labels]\": fn}\n * \t\t\t\t\t\t\t\t\t\t\tor {hubName: {\"topics[; labels]\": fn}}\n * @returns {hub, topics, labels}[]\n */\nfunction listHubInfos(hubEvents) {\n    const infoList = [];\n    for (const key in hubEvents) {\n        const val = hubEvents[key];\n        // If we have FnBySelector, then, hub name is in the selector, getHubInfo will extract it\n        // \"hubName; topics[; labels]\": fn}\n        if (val instanceof Function) {\n            infoList.push(getHubInfo(key, null, val));\n        }\n        // otherwise, if val is an object, then, thee key is the name of the hub, so get/create it.\n        // {hubName: {\"topics[; labels]\": fn}}\n        else {\n            const _hub = hub(key);\n            for (const key2 in val) {\n                infoList.push(getHubInfo(key2, _hub, val[key2]));\n            }\n        }\n    }\n    return infoList;\n}\n// returns {hub, topics, labels}\n// hub is optional, if not present, assume the name will be the first item will be in the str\nfunction getHubInfo(str, _hub, fun) {\n    const a = splitAndTrim(str, \";\");\n    // if no hub, then, assume it is in the str\n    const topicIdx = (_hub) ? 0 : 1;\n    _hub = (!_hub) ? hub(a[0]) : _hub;\n    const info = {\n        topics: a[topicIdx],\n        fun: fun,\n        hub: _hub\n    };\n    if (a.length > topicIdx + 1) {\n        info.labels = a[topicIdx + 1];\n    }\n    return info;\n}\n//#endregion ---------- /Private Helpers ---------- \n//#region    ---------- Public Factory ---------- \n/** Singleton hub factory */\nexport function hub(name) {\n    if (name == null) {\n        throw new Error('dom-native INVALID API CALLS: hub(name) require a name (no name was given).');\n    }\n    let hub = hubDic.get(name);\n    // if it does not exist, we create and set it. \n    if (hub === undefined) {\n        hub = new HubImpl(name);\n        hubDic.set(name, hub);\n        // create the hubData\n        hubDataDic.set(name, new HubData(name));\n    }\n    return hub;\n}\n// User Hub object exposing the public API\nconst hubDic = new Map();\n// Data for each hub (by name)\nconst hubDataDic = new Map();\nclass HubImpl {\n    constructor(name) {\n        this.name = name;\n    }\n    sub(topics, labels_or_handler, handler_or_opts, opts) {\n        //// Build the arguments\n        let labels;\n        let handler;\n        // if the first arg is function, then, no labels\n        if (labels_or_handler instanceof Function) {\n            labels = null;\n            handler = labels_or_handler;\n            opts = handler_or_opts;\n        }\n        else {\n            labels = labels_or_handler;\n            handler = handler_or_opts;\n            // opts = opts;\n        }\n        //// Normalize topic and label to arrays\n        const topicArray = splitAndTrim(topics, \",\");\n        const labelArray = (labels != null) ? splitAndTrim(labels, \",\") : null;\n        //// make opts (always defined at least an emtpy object)\n        opts = makeOpts(opts);\n        //// add the event to the hubData\n        const hubData = hubDataDic.get(this.name); // by hub(...) factory function, this is garanteed\n        hubData.addEvent(topicArray, labelArray, handler, opts);\n    }\n    unsub(ns) {\n        const hubData = hubDataDic.get(this.name); // by factory contract, this always exist.\n        hubData.removeRefsForNs(ns.ns);\n    }\n    pub(topics, labels, data) {\n        // ARG SHIFTING: if data is undefined, we shift args to the RIGHT\n        if (typeof data === \"undefined\") {\n            data = labels;\n            labels = null;\n        }\n        //// Normalize topic and label to arrays\n        const topicArray = splitAndTrim(topics, \",\");\n        const labelArray = (labels != null) ? splitAndTrim(labels, \",\") : null;\n        const hubData = hubDataDic.get(this.name);\n        const hasLabels = (labels != null && labels.length > 0);\n        // if we have labels, then, we send the labels bound events first\n        if (hasLabels) {\n            hubData.getRefs(topicArray, labelArray).forEach(function (ref) {\n                invokeRef(ref, data);\n            });\n        }\n        // then, we send the topic only bound\n        hubData.getRefs(topicArray, null).forEach(function (ref) {\n            // if this send, has label, then, we make sure we invoke for each of this label\n            if (hasLabels) {\n                labelArray.forEach(function (label) {\n                    invokeRef(ref, data, label);\n                });\n            }\n            // if we do not have labels, then, just call it.\n            else {\n                invokeRef(ref, data);\n            }\n        });\n    }\n    deleteHub() {\n        hubDic.delete(this.name);\n        hubDataDic.delete(this.name);\n    }\n}\n// TODO: This was maded to have it private to the hub. Now that we are using trypescript, we might want to use private and store it in the Hub. \nclass HubData {\n    constructor(name) {\n        this.refsByNs = new Map();\n        this.refsByTopic = new Map();\n        this.refsByTopicLabel = new Map();\n        this.name = name;\n    }\n    addEvent(topics, labels, fun, opts) {\n        const refs = buildRefs(topics, labels, fun, opts);\n        const refsByNs = this.refsByNs;\n        const refsByTopic = this.refsByTopic;\n        const refsByTopicLabel = this.refsByTopicLabel;\n        refs.forEach(function (ref) {\n            // add this ref to the ns dictionary\n            // TODO: probably need to add an custom \"ns\"\n            if (ref.ns != null) {\n                ensureArray(refsByNs, ref.ns).push(ref);\n            }\n            // if we have a label, add this ref to the topicLabel dictionary\n            if (ref.label != null) {\n                ensureArray(refsByTopicLabel, buildTopicLabelKey(ref.topic, ref.label)).push(ref);\n            }\n            // Otherwise, add it to this ref this topic\n            else {\n                ensureArray(refsByTopic, ref.topic).push(ref);\n            }\n        });\n    }\n    ;\n    getRefs(topics, labels) {\n        const refs = [];\n        const refsByTopic = this.refsByTopic;\n        const refsByTopicLabel = this.refsByTopicLabel;\n        topics.forEach(function (topic) {\n            // if we do not have labels, then, just look in the topic dic\n            if (labels == null || labels.length === 0) {\n                const topicRefs = refsByTopic.get(topic);\n                if (topicRefs) {\n                    refs.push.apply(refs, topicRefs);\n                }\n            }\n            // if we have some labels, then, take those in accounts\n            else {\n                labels.forEach(function (label) {\n                    const topicLabelRefs = refsByTopicLabel.get(buildTopicLabelKey(topic, label));\n                    if (topicLabelRefs) {\n                        refs.push.apply(refs, topicLabelRefs);\n                    }\n                });\n            }\n        });\n        return refs;\n    }\n    ;\n    removeRefsForNs(ns) {\n        const refsByTopic = this.refsByTopic;\n        const refsByTopicLabel = this.refsByTopicLabel;\n        const refsByNs = this.refsByNs;\n        const refs = this.refsByNs.get(ns);\n        if (refs != null) {\n            // we remove each ref from the corresponding dic\n            refs.forEach(function (ref) {\n                // First, we get the refs from the topic or topiclabel\n                let refList;\n                if (ref.label != null) {\n                    const topicLabelKey = buildTopicLabelKey(ref.topic, ref.label);\n                    refList = refsByTopicLabel.get(topicLabelKey);\n                }\n                else {\n                    refList = refsByTopic.get(ref.topic);\n                }\n                // Then, for the refList array, we remove the ones that match this object\n                let idx;\n                while ((idx = refList.indexOf(ref)) !== -1) {\n                    refList.splice(idx, 1);\n                }\n            });\n            // we remove them all form the refsByNs\n            refsByNs.delete(ns);\n        }\n    }\n    ;\n}\n// static/private\nfunction buildRefs(topics, labels, fun, opts) {\n    let refs = [];\n    topics.forEach(function (topic) {\n        // if we do not have any labels, then, just add this topic\n        if (labels == null || labels.length === 0) {\n            refs.push({\n                topic: topic,\n                fun: fun,\n                ns: opts.ns,\n                ctx: opts.ctx\n            });\n        }\n        // if we have one or more labels, then, we add for those label\n        else {\n            labels.forEach(function (label) {\n                refs.push({\n                    topic: topic,\n                    label: label,\n                    fun: fun,\n                    ns: opts.ns,\n                    ctx: opts.ctx\n                });\n            });\n        }\n    });\n    return refs;\n}\n// static/private: return a safe opts. If opts is a string, then, assume is it the {ns}\nconst emptyOpts = {};\nfunction makeOpts(opts) {\n    if (opts == null) {\n        opts = emptyOpts;\n    }\n    else {\n        if (typeof opts === \"string\") {\n            opts = { ns: opts };\n        }\n    }\n    return opts;\n}\n// static/private\nfunction buildTopicLabelKey(topic, label) {\n    return topic + \"-!-\" + label;\n}\n// static/private: call ref method (with optional label override)\nfunction invokeRef(ref, data, label) {\n    const info = {\n        topic: ref.topic,\n        label: ref.label || label,\n        ns: ref.ns\n    };\n    ref.fun.call(ref.ctx, data, info);\n}\n//#endregion ---------- /Hub Implementation ----------\n//# sourceMappingURL=hub.js.map","import { off, on } from './event.js';\nconst _onEventsByConstructor = new Map();\nconst _computedOnDOMEventsByConstructor = new WeakMap();\n//#region    ---------- Public onEvent Decorator ---------- \nexport function onEvent(type, selector_or_opts, opts) {\n    return _onDOMEvent(null, type, selector_or_opts, opts);\n}\nexport function onDoc(type, selector_or_opts, opts) {\n    return _onDOMEvent(document, type, selector_or_opts, opts);\n}\nexport function onWin(type, selector_or_opts, opts) {\n    return _onDOMEvent(window, type, selector_or_opts, opts);\n}\n//#endregion ---------- /Public onEvent Decorator ---------- \n// the decorator function\nfunction _onDOMEvent(evtTarget, type, selector_or_opts, opts) {\n    let selector = (typeof selector_or_opts == 'string') ? selector_or_opts : null;\n    opts = (selector === null) ? selector_or_opts : opts;\n    // target references the element's class. It will be the constructor function for a static method or the prototype of the class for an instance member\n    return function (target, propertyKey, descriptor) {\n        const fn = descriptor.value;\n        const clazz = target.constructor;\n        // get the onEvents array for this clazz\n        let onEvents = _onEventsByConstructor.get(clazz);\n        if (onEvents == null) {\n            onEvents = [];\n            _onEventsByConstructor.set(clazz, onEvents);\n        }\n        // create and push the event\n        const onEvent = {\n            target: evtTarget,\n            name: propertyKey,\n            type: type,\n            selector: selector,\n            opts\n        };\n        onEvents.push(onEvent);\n    };\n}\n/** Bind the element OnDOMEvent registred in the decorator _onDOMEvent  */\nexport function bindOnElementEventsDecorators(el) {\n    const clazz = el.constructor;\n    const computedOnDOMEvents = getComputeOnDOMEvents(clazz);\n    if (computedOnDOMEvents != null) {\n        const { elOnDOMEvents } = computedOnDOMEvents;\n        if (elOnDOMEvents !== null) {\n            const eventOpts = { ...el._nsObj, ctx: el };\n            for (const onEvent of elOnDOMEvents) {\n                const target = (el.shadowRoot) ? el.shadowRoot : el;\n                const fn = el[onEvent.name];\n                _bindOn(target, onEvent, fn, eventOpts);\n            }\n        }\n    }\n}\nexport function bindOnParentEventsDecorators(el) {\n    const clazz = el.constructor;\n    const computedOnDOMEvents = getComputeOnDOMEvents(clazz);\n    const { docOnDOMEvents, winOnDOMEvents } = computedOnDOMEvents;\n    const eventOpts = { ...el._nsObj, ctx: el, silenceDisconnectedCtx: true };\n    if (docOnDOMEvents !== null) {\n        for (const onEvent of docOnDOMEvents) {\n            const fn = el[onEvent.name];\n            _bindOn(onEvent.target, onEvent, fn, eventOpts);\n        }\n    }\n    if (winOnDOMEvents !== null) {\n        for (const onEvent of winOnDOMEvents) {\n            const fn = el[onEvent.name];\n            _bindOn(onEvent.target, onEvent, fn, eventOpts);\n        }\n    }\n}\n// Private bindOn. Here the target should be resolved before, won't take the onEvent.target\nfunction _bindOn(target, onEvent, fn, baseEventOpts) {\n    let opts = baseEventOpts;\n    if (onEvent.opts) {\n        opts = { ...baseEventOpts, ...onEvent.opts };\n    }\n    on(target, onEvent.type, onEvent.selector, fn, opts);\n}\n// Return (and Compute if needed) the ComputedOnDOMEvents for a topClazz and store it in the \n// Note: At this point, the parent classes will be process but their ComputedOnDOMEvents won't be computed.\n//       This could be a further optimization at some point, but not sure it will give big gain, since now this logic\n//       happen only one for the first instantiation of the class type object.\nfunction getComputeOnDOMEvents(clazz) {\n    const alreadyComputed = _computedOnDOMEventsByConstructor.get(clazz);\n    if (alreadyComputed) {\n        return alreadyComputed;\n    }\n    const topClazz = clazz;\n    const elOnDOMEvents = [];\n    const docOnDOMEvents = [];\n    const winOnDOMEvents = [];\n    // Keep track of the `function_name` already bound by children classes to avoid double bind for the name function name.\n    // This is the intuitive behavior, aligning with inheritance behavior.\n    // This works because we are walking the hierarchy tree from child to parent.\n    const childrenBoundFnNames = new Set();\n    // --- Compute the ComputedOnDOMEvents\n    do {\n        const onEvents = _onEventsByConstructor.get(clazz);\n        if (onEvents) {\n            const clazzBoundFnNames = new Set();\n            for (const onEvent of onEvents) {\n                const target = onEvent.target;\n                const fnName = onEvent.name;\n                // bind only if this function name was not already bound by a children\n                if (!childrenBoundFnNames.has(fnName)) {\n                    // get the appropriate onDOMEvents list to push this event given the target\n                    let onDOMEvents;\n                    if (target === window) {\n                        onDOMEvents = winOnDOMEvents;\n                    }\n                    else if (target === document) {\n                        onDOMEvents = docOnDOMEvents;\n                    }\n                    else {\n                        onDOMEvents = elOnDOMEvents;\n                    }\n                    onDOMEvents.push(onEvent);\n                    // add the name to this class boundFnNames to be added to the childrenBoundFnNames later\n                    clazzBoundFnNames.add(fnName);\n                }\n            } // for onEvent of onEvents\n            // add this class bound fnNames to the childrenBoudFnNames for next parent class resolution\n            for (const fnName of clazzBoundFnNames) {\n                childrenBoundFnNames.add(fnName);\n            }\n        }\n        // get the parent class\n        // clazz = (<any>clazz).__proto__;\n        clazz = Object.getPrototypeOf(clazz);\n    } while (clazz !== HTMLElement);\n    const computedOnDOMEvents = {\n        elOnDOMEvents: elOnDOMEvents.length > 0 ? elOnDOMEvents : null,\n        docOnDOMEvents: docOnDOMEvents.length > 0 ? docOnDOMEvents : null,\n        winOnDOMEvents: winOnDOMEvents.length > 0 ? winOnDOMEvents : null,\n    };\n    _computedOnDOMEventsByConstructor.set(topClazz, computedOnDOMEvents);\n    return computedOnDOMEvents;\n}\nexport function hasParentEventsDecorators(el) {\n    const clazz = el.constructor;\n    const computed = getComputeOnDOMEvents(clazz);\n    return (computed.docOnDOMEvents != null || computed.winOnDOMEvents != null);\n}\n// only unbind docEvent and winEvent\nexport function unbindParentEventsDecorators(el) {\n    const clazz = el.constructor;\n    const computed = getComputeOnDOMEvents(clazz);\n    if (computed.docOnDOMEvents != null) {\n        off(document, el._nsObj);\n    }\n    if (computed.winOnDOMEvents != null) {\n        off(window, el._nsObj);\n    }\n}\n//# sourceMappingURL=ts-decorator-on-event.js.map","import { hub } from './hub.js';\nconst _onHubEventByConstructor = new Map();\nconst _computedOnHubEventByConstructor = new WeakMap();\n//#region    ---------- Public onEvent Decorator ---------- \n/**\n * `onHub` decorator to bind a hub event to this instance.\n */\nexport function onHub(hubName, topic, label) {\n    // target references the element's class. It will be the constructor function for a static method or the prototype of the class for an instance member\n    return function (target, propertyKey, descriptor) {\n        const clazz = target.constructor;\n        // get the onEvents array for this clazz\n        let onEvents = _onHubEventByConstructor.get(clazz);\n        if (onEvents == null) {\n            onEvents = [];\n            _onHubEventByConstructor.set(clazz, onEvents);\n        }\n        // create and push the event\n        const onEvent = {\n            methodName: propertyKey,\n            hubName,\n            topic,\n            label\n        };\n        onEvents.push(onEvent);\n    };\n}\n//#endregion ---------- /Public onEvent Decorator ---------- \nexport function hasHubEventDecorators(el) {\n    return getComputedOnHubEvents(el.constructor) != null;\n}\n// For BaseHTMLElement\nexport function bindOnHubDecorators() {\n    let clazz = this.constructor;\n    const computed = getComputedOnHubEvents(clazz);\n    if (computed != null) {\n        const opts = { ...this._nsObj, ctx: this };\n        for (const onEvent of computed) {\n            const fnName = onEvent.methodName;\n            const fn = this[fnName];\n            const h = hub(onEvent.hubName);\n            h.sub(onEvent.topic, onEvent.label, fn, opts);\n        }\n    }\n}\n// only unbind docEvent and winEvent\nexport function unbindOnHubDecorators() {\n    let clazz = this.constructor;\n    const computed = getComputedOnHubEvents(clazz);\n    const nsObj = this._nsObj;\n    if (computed != null) {\n        for (const onEvent of computed) {\n            const { hubName, methodName } = onEvent;\n            const h = hub(hubName);\n            h.unsub(nsObj);\n        }\n    }\n}\nfunction getComputedOnHubEvents(clazz) {\n    const topClazz = clazz;\n    const topClazzHubEvents = [];\n    // keep track of the function name that were bound, to not double bind overriden parents\n    // This is the intuitive behavior, aligning with inheritance behavior.\n    const fnNameBoundSet = new Set();\n    do {\n        const onEvents = _onHubEventByConstructor.get(clazz);\n        if (onEvents) {\n            for (const onEvent of onEvents) {\n                const fnName = onEvent.methodName;\n                if (!fnNameBoundSet.has(fnName)) {\n                    topClazzHubEvents.push(onEvent);\n                    fnNameBoundSet.add(fnName);\n                }\n            }\n        }\n        // clazz = (<any>clazz).__proto__;\n        clazz = Object.getPrototypeOf(clazz);\n    } while (clazz != HTMLElement);\n    const computed = topClazzHubEvents.length > 0 ? topClazzHubEvents : null;\n    _computedOnHubEventByConstructor.set(topClazz, computed);\n    return computed;\n}\n//# sourceMappingURL=ts-decorator-on-hub.js.map","// (c) 2019 BriteSnow, inc - This code is licensed under MIT license (see LICENSE for details)\nimport { bindOnEvents, off } from './event.js';\nimport { bindHubEvents, unbindHubEvents } from './hub.js';\nimport { bindOnElementEventsDecorators, bindOnParentEventsDecorators, hasParentEventsDecorators, unbindParentEventsDecorators } from './ts-decorator-on-event.js';\nimport { bindOnHubDecorators, hasHubEventDecorators, unbindOnHubDecorators } from './ts-decorator-on-hub.js';\n// component unique sequence number to allow to have cheap UID for each component\nlet c_seq = 0;\n/**\n * BaseHTMLElement that all custom elements from this application should inherit from.\n *\n * SubClass Usage:\n *   - `init()` to create/modify the innerHTML/children, bind events. Must call `super.init()`\n *   - `this.uid` is the unique id for this component instance, so, can use to bind parent element events for later cleanup.\n *   - `disconnectedCallback()` to unbind any events bound to the parent of the component (document event binding). Must call `super.disconnectedCallback()`\n *\n * Important:\n *   - SubClass should/must override `init()` but never call `init()` from anywhere. Only `BaseHTMLElement.connectedCallback()` implementation should call `init()`\n *   - All calls to custom element interface `disconnectedCallback()` `connectedCallback()` `attributeChangedCallback()` MUST call their `super...` method.\n *\n */\nexport class BaseHTMLElement extends HTMLElement {\n    constructor() {\n        super();\n        // lifecyle _init state\n        this._init = false;\n        this._parent_bindings_done = false;\n        this._parent_unbindings_planned = false;\n        this._hub_bindings_done = false;\n        this._preDisplay_attached = false;\n        this._postDisplay_attached = false;\n        this.uid = 'c_uid_' + c_seq++;\n        this._nsObj = { ns: this.uid };\n    }\n    get initialized() { return this._init; }\n    /**\n     * Method to override to create child elements. Will be called only once by the BaseHTMLElement `connectedCallback()` implementation.\n     *\n     * - Best Pratice: call `super.init()` when overriden.\n     * - DO NOT call this method, this is called by BaseHTMLElement internal.\n     *\n     */\n    init() { }\n    /**\n     * Base implementation of `connectedCallback` that will call `this.init()` once.\n     *\n     * - MUST call `super.connectedCallback()` when overriden.\n     */\n    connectedCallback() {\n        const opts = { ns: this._nsObj.ns, ctx: this };\n        if (this._has_parent_events == null) {\n            this._has_parent_events = this.docEvents != null || this.winEvents != null || hasParentEventsDecorators(this);\n        }\n        // --- Bind the eventual parent events (document, windows)\n        // Note: Parent events are silenced on when el is diconnected, and unbound when next frame still diconnected\n        if (this._has_parent_events && !this._parent_bindings_done) {\n            // bind the @docDoc event\n            if (this.docEvents)\n                bindOnEvents(document, this.docEvents, { ...opts, silenceDisconnectedCtx: true });\n            // bind the @docWin event\n            if (this.winEvents)\n                bindOnEvents(window, this.winEvents, { ...opts, silenceDisconnectedCtx: true });\n            bindOnParentEventsDecorators(this);\n            this._parent_bindings_done = true;\n        }\n        // --- Bind the hub if not already done\n        // Note: Hub events are bound and unbound on each connect and disconnect. \n        //       (could use the parent event optimation later)\n        if (!this._hub_bindings_done) {\n            if (this.hubEvents)\n                bindHubEvents(this.hubEvents, opts);\n            bindOnHubDecorators.call(this);\n            this._hub_bindings_done = true;\n        }\n        // --- Peform the init\n        if (!this._init) {\n            if (this.events)\n                bindOnEvents(this, this.events, opts);\n            // bind the @onEvent decorated methods\n            bindOnElementEventsDecorators(this);\n            this.init();\n            this._init = true;\n        }\n        // --- Register the eventual preDisplay / postDisplay\n        // Note - Will pass the \"firstCall\" flag to both method. \n        if (this.preDisplay) {\n            let firstCall = !(this._preDisplay_attached === true);\n            requestAnimationFrame(() => {\n                this.preDisplay(firstCall);\n                this._preDisplay_attached = false;\n            });\n        }\n        if (this.postDisplay) {\n            let firstCall = !(this._postDisplay_attached === true);\n            this._postDisplay_attached = true;\n            requestAnimationFrame(() => {\n                requestAnimationFrame(() => {\n                    this.postDisplay(firstCall);\n                    this._postDisplay_attached = false;\n                });\n            });\n        }\n    }\n    /**\n     * Empty implementation to allow `super.disconnectedCallback()` best practices on sub classes\n     */\n    disconnectedCallback() {\n        // NOTE: Here we detached\n        if (this._has_parent_events === true) {\n            requestAnimationFrame(() => {\n                if (!this.isConnected) {\n                    if (this.docEvents) {\n                        off(document, this._nsObj);\n                    }\n                    if (this.winEvents) {\n                        off(window, this._nsObj);\n                    }\n                    unbindParentEventsDecorators(this);\n                    this._parent_bindings_done = false;\n                }\n            });\n        }\n        if (this.hubEvents || hasHubEventDecorators(this)) {\n            if (this.hubEvents != null) {\n                unbindHubEvents(this.hubEvents, this._nsObj);\n            }\n            unbindOnHubDecorators.call(this);\n            this._hub_bindings_done = false;\n        }\n    }\n}\nexport function addDOMEvents(target, source) {\n    return Object.assign(target || {}, source);\n}\nexport function addHubEvents(target, source) {\n    const t = (target == null) ? [] : (target instanceof Array) ? target : [target];\n    (source instanceof Array) ? t.push(...source) : t.push(source);\n    return t;\n}\n//# sourceMappingURL=c-base.js.map","// Implementation Note: Using 'String' rather than 'string' in the typing above is critical to allow to get A[K] to match TagName type. \n//       Which will allow to correctly type `elem('input', 'un-known') // type[HTMLInputElement, HTMLElement]`\n//       Otherwise, if use 'string', all A[K] will become \"wider\" and won't match to TagName, so all types are HTMLElement\nexport function elem(...args) {\n    const arg0Type = typeof args[0];\n    const arg1Type = typeof args[1];\n    // if we have a single element create\n    if (arg0Type == 'string' && (arg1Type == 'object' || arg1Type == 'undefined')) {\n        return createEl(args[0], args[1]);\n    }\n    // otherwise, have a list of tagNames (for now, do not support properties for list of tag name)\n    else {\n        return args.map(n => { return document.createElement(n); });\n    }\n}\n// private function to create a el with some eventual properties. \nfunction createEl(tagName, data) {\n    let el = document.createElement(tagName);\n    if (data != null) {\n        for (const [name, rawVal] of Object.entries(data)) {\n            // if it is a boolean, true will set the attribute empty, and false will set txtVal to null, which will remove it.\n            const val = (typeof rawVal !== 'boolean') ? rawVal : (rawVal === true) ? '' : null;\n            if (val !== null) {\n                const valTxt = (typeof val == 'string') ? val : ('' + val);\n                // \"$\" does a property assign of it's member\n                if (name == '$') {\n                    const props = val;\n                    for (const [name, rawVal] of Object.entries(props)) {\n                        el[name] = rawVal;\n                    }\n                }\n                // _textContent (to deprecate) - set the \n                // if _textContent then, it's the el.textContent ()\n                else if (name == '_textContent') {\n                    el.textContent = valTxt;\n                }\n                else {\n                    el.setAttribute(name, valTxt);\n                }\n            }\n            // if the value is null, we do nothing\n        }\n    }\n    return el;\n}\nexport function html(strings, ...values) {\n    let html;\n    if (typeof strings === 'string') {\n        html = strings.trim();\n    }\n    else {\n        let r = '';\n        for (let i = 0; i < strings.length; i++) {\n            r += strings[i] + (values[i] ?? '');\n        }\n        // make it null proof\n        html = r;\n    }\n    const template = document.createElement(\"template\");\n    if (html) {\n        template.innerHTML = html;\n    }\n    return template.content;\n}\nexport function frag(items, acc) {\n    const frag = new DocumentFragment();\n    if (items == null) {\n        return frag;\n    }\n    for (const item of items) {\n        const el = acc(item);\n        frag.appendChild(el);\n    }\n    return frag;\n}\n//# sourceMappingURL=dom-builders.js.map","const _elHtml = document.createElement('div');\n/** Shortname for escapeHtml */\nexport const xh = escapeHtml;\n/** Escape a HTML content using native DOM textContent to innerHTML capability */\nexport function escapeHtml(txt) {\n    _elHtml.textContent = txt;\n    const safeTxt = _elHtml.innerHTML;\n    _elHtml.textContent = null;\n    return safeTxt;\n}\nconst _elAttr = document.createElement('e');\n/** Shortname for escapeAttr */\nexport const xa = escapeAttr;\n/** Escape a string as a HTML Attribute content using native DOM attribute serialization */\nexport function escapeAttr(txt) {\n    _elAttr.setAttribute('a', txt);\n    // .outerHTML will generate '<e a=\"...\"></e>';\n    const html = _elAttr.outerHTML;\n    const safeTxt = html.substring(6, html.length - 6);\n    _elHtml.setAttribute('a', '');\n    return safeTxt;\n}\n//# sourceMappingURL=escapes.js.map","export function customElement(tagName) {\n    // target references the element's class. \n    return function (target) {\n        customElements.define(tagName, target);\n    };\n}\n//# sourceMappingURL=ts-decorator-custom-element.js.map",null],"names":[],"mappings":"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"}